import { Given, When, Then } from "@cucumber/cucumber";
import { expect } from "@playwright/test";
import { CategoryDomain } from "../../domain/CategoryDomain";
import { CategoryFormData } from "../../types/CategoryTypes";
import { generateUniqueName } from "../../utils/testDataHelper";
import { createCategory } from "../../api/categoryApiHelper";
import { logger } from "../../support/logger";
import { CustomWorld } from "../../support/world";
import { config } from "../../config/env.config";

/**
 * Business-focused step definitions following BDD principles
 * Focus on WHAT the user wants to achieve, not HOW
 */

// Background steps
Given(
  "I am on the Money Keeper application",
  async function (this: CustomWorld) {
    await this.page.goto(config.browser.baseUrl);
  }
);

Given(
  "I have access to the category management features",
  async function (this: CustomWorld) {
    const categoryDomain = new CategoryDomain(this.page);
    this.categoryDomain = categoryDomain;
    
    // Navigate to categories page
    await this.page.locator('[data-testid="page-title"]').click();
    await this.page.waitForLoadState("networkidle");
  }
);

// Given steps for test data setup
Given(
  "I have an existing category called {string}",
  async function (this: CustomWorld, categoryName: string) {
    const uniqueName = generateUniqueName(categoryName);
    this.uniqueData.set(categoryName, uniqueName);
    
    // Create via API for better test isolation
    const newCategory = await createCategory({
      name: uniqueName,
      icon: "Grid",
      type: "EXPENSE",
      parentId: null,
    });
    
    this.trackCreatedCategory(newCategory.id, uniqueName);
    
    // Refresh UI to reflect backend changes
    await this.refreshCategoryPage();
    
    logger.info(`Created category: ${uniqueName}`);
  }
);

Given(
  "I have multiple categories including {string} and {string}",
  async function (this: CustomWorld, category1: string, category2: string) {
    const uniqueName1 = generateUniqueName(category1);
    const uniqueName2 = generateUniqueName(category2);
    
    this.uniqueData.set(category1, uniqueName1);
    this.uniqueData.set(category2, uniqueName2);
    
    // Create categories via API
    const newCategory1 = await createCategory({
      name: uniqueName1,
      icon: "Grid",
      type: "EXPENSE",
      parentId: null,
    });
    
    const newCategory2 = await createCategory({
      name: uniqueName2,
      icon: "Grid",
      type: "EXPENSE",
      parentId: null,
    });
    
    this.trackCreatedCategory(newCategory1.id, uniqueName1);
    this.trackCreatedCategory(newCategory2.id, uniqueName2);
    
    await this.refreshCategoryPage();
    
    logger.info(`Created categories: ${uniqueName1}, ${uniqueName2}`);
  }
);

Given(
  "I have both income and expense categories",
  async function (this: CustomWorld) {
    const expenseUniqueName = generateUniqueName("Expense Category");
    const incomeUniqueName = generateUniqueName("Income Category");
    
    this.uniqueData.set("Expense Category", expenseUniqueName);
    this.uniqueData.set("Income Category", incomeUniqueName);
    
    const expenseCategory = await createCategory({
      name: expenseUniqueName,
      icon: "Grid",
      type: "EXPENSE",
      parentId: null,
    });
    
    const incomeCategory = await createCategory({
      name: incomeUniqueName,
      icon: "Grid",
      type: "INCOME",
      parentId: null,
    });
    
    this.trackCreatedCategory(expenseCategory.id, expenseUniqueName);
    this.trackCreatedCategory(incomeCategory.id, incomeUniqueName);
    
    await this.refreshCategoryPage();
    
    logger.info(`Created income and expense categories`);
  }
);

// When steps - Business actions
When(
  "I want to create a new {string} category called {string}",
  async function (this: CustomWorld, categoryType: string, categoryName: string) {
    const uniqueName = generateUniqueName(categoryName);
    this.uniqueData.set(categoryName, uniqueName);
    
    const categoryData: CategoryFormData = {
      name: uniqueName,
      icon: "Grid",
      type: categoryType as 'INCOME' | 'EXPENSE',
      parentCategory: ""
    };
    
    this.pendingCategoryData = categoryData;
    logger.info(`Preparing to create ${categoryType} category: ${uniqueName}`);
  }
);

When(
  "I assign it the {string} icon",
  async function (this: CustomWorld, icon: string) {
    if (this.pendingCategoryData && this.categoryDomain) {
      this.pendingCategoryData.icon = icon;
      
      // Now execute the creation
      await this.categoryDomain.createCategory(this.pendingCategoryData);
      this.trackCreatedCategory(null, this.pendingCategoryData.name);
      
      logger.info(`Created category with icon: ${icon}`);
    }
  }
);

When(
  "I want to rename it to {string}",
  async function (this: CustomWorld, newName: string) {
    const uniqueName = generateUniqueName(newName);
    this.uniqueData.set(newName, uniqueName);
    
    // Get the original category name from context
    const originalCategory = Array.from(this.uniqueData.keys())[0];
    const originalUniqueName = this.uniqueData.get(originalCategory);
    
    if (originalUniqueName && this.categoryDomain) {
      const newCategoryData: CategoryFormData = {
        name: uniqueName,
        icon: "Food",
        type: "EXPENSE",
        parentCategory: ""
      };
      
      await this.categoryDomain.updateCategory(originalUniqueName, newCategoryData);
      this.trackCreatedCategory(null, uniqueName);
      
      logger.info(`Renamed category from ${originalUniqueName} to ${uniqueName}`);
    }
  }
);

When(
  "I decide to delete this category",
  async function (this: CustomWorld) {
    const categoryToDelete = this.getLastCreatedCategory();
    
    if (categoryToDelete && this.categoryDomain) {
      await this.categoryDomain.deleteCategory(categoryToDelete);
      this.removeFromTrackedCategories(categoryToDelete);
      
      logger.info(`Deleted category: ${categoryToDelete}`);
    }
  }
);

When(
  "I confirm the deletion",
  async function (this: CustomWorld) {
    // Confirmation is handled within the deleteCategory method
    logger.info("Deletion confirmed");
  }
);

When(
  "I search for {string}",
  async function (this: CustomWorld, searchTerm: string) {
    if (this.categoryDomain) {
      await this.categoryDomain.searchCategories({ searchTerm });
      logger.info(`Searched for: ${searchTerm}`);
    }
  }
);

When(
  "I filter by {string} categories",
  async function (this: CustomWorld, filterType: string) {
    if (this.categoryDomain) {
      await this.categoryDomain.searchCategories({ 
        categoryType: filterType as 'INCOME' | 'EXPENSE' 
      });
      logger.info(`Filtered by: ${filterType}`);
    }
  }
);

When(
  "I try to create a category without providing a name",
  async function (this: CustomWorld) {
    if (this.categoryDomain) {
      try {
        const invalidCategoryData: CategoryFormData = {
          name: "",
          icon: "Grid",
          type: "EXPENSE",
          parentCategory: ""
        };
        
        await this.categoryDomain.createCategory(invalidCategoryData);
      } catch (error) {
        this.lastError = error as Error;
        logger.info("Category creation failed as expected due to validation");
      }
    }
  }
);

When(
  "I decide to cancel the operation",
  async function (this: CustomWorld) {
    if (this.categoryDomain) {
      await this.categoryDomain.cancelCurrentOperation();
      logger.info("Operation cancelled");
    }
  }
);

// Then steps - Business verifications
Then(
  "the category {string} should be available for use",
  async function (this: CustomWorld, categoryName: string) {
    const uniqueName = this.uniqueData.get(categoryName) || categoryName;
    if (this.categoryDomain) {
      const exists = await this.categoryDomain.categoryExists(uniqueName);
      expect(exists).toBe(true);
      
      logger.info(`Verified category exists: ${uniqueName}`);
    }
  }
);

Then(
  "I should be able to see it in my category list",
  async function (this: CustomWorld) {
    // This verification is implicit in the previous step
    logger.info("Category visibility verified");
  }
);

Then(
  "the category {string} should no longer appear in my list",
  async function (this: CustomWorld, categoryName: string) {
    const uniqueName = this.uniqueData.get(categoryName) || categoryName;
    if (this.categoryDomain) {
      const exists = await this.categoryDomain.categoryExists(uniqueName);
      expect(exists).toBe(false);
      
      logger.info(`Verified category no longer exists: ${uniqueName}`);
    }
  }
);

Then(
  "I should see {string} in the results",
  async function (this: CustomWorld, categoryName: string) {
    const uniqueName = this.uniqueData.get(categoryName) || categoryName;
    if (this.categoryDomain) {
      const exists = await this.categoryDomain.categoryExists(uniqueName);
      expect(exists).toBe(true);
      
      logger.info(`Verified category in search results: ${uniqueName}`);
    }
  }
);

Then(
  "I should not see {string} in the results",
  async function (this: CustomWorld, categoryName: string) {
    const uniqueName = this.uniqueData.get(categoryName) || categoryName;
    if (this.categoryDomain) {
      const exists = await this.categoryDomain.categoryExists(uniqueName);
      expect(exists).toBe(false);
      
      logger.info(`Verified category not in search results: ${uniqueName}`);
    }
  }
);

Then(
  "I should see an error message {string}",
  async function (this: CustomWorld, expectedMessage: string) {
    expect(this.lastError).toBeDefined();
    expect(this.lastError?.message).toContain(expectedMessage);
    
    logger.info(`Verified error message: ${expectedMessage}`);
  }
);

Then(
  "the category should not be created",
  async function (this: CustomWorld) {
    // This verification is implicit in the error handling
    logger.info("Verified category was not created");
  }
);
